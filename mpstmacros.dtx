% \iffalse meta-comment
% vim: textwidth=75
%<*internal>
\iffalse
%</internal>
%<*readme>
----------:| --------------------------------------------------------------
mpstmacros:| Macros for multiparty session types
    Author:| Fangyi Zhou
    E-mail:| me@fangyi.io
   License:| The Unlicense
       See:| https://unlicense.org/

This work consists of the file mpstmacros.dtx and a Makefile.
Running "make" generates the derived files README, mpstmacros.pdf and mpstmacros.sty.

Short description:
A package for multiparty session type macros
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------:| --------------------------------------------------------------
mpstmacros:| Macros for multiparty session types
    Author:| Fangyi Zhou
    E-mail:| me@fangyi.io
   License:| The Unlicense
       See:| https://unlicense.org/

\endpreamble
\postamble

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>

This work consists of the file mpstmacros.dtx and a Makefile.
Running "make" generates the derived files README, mpstmacros.pdf and mpstmacros.sty.
Running "make inst" installs the files in the user's TeX tree.
Running "make install" installs the files in the local TeX tree.

\endpostamble

\usedir{tex/latex/mpstmacros}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/mpstmacros}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/mpstmacros}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{mpstmacros.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{mpstmacros}
%<*package>
    [2022/02/11 v0.0.3 Fix missing package]
%</package>
%<package>\RequirePackage[svgnames]{xcolor}
%<package>\RequirePackage{xifthen}
%<package>\RequirePackage{amsmath}
%<*driver>
\documentclass{ltxdoc}
\usepackage[a4paper,margin=25mm,left=50mm,nohead]{geometry}
\usepackage[numbered]{hypdoc}
\usepackage[T1]{fontenc}
\usepackage{palatino}
\usepackage{mathpazo}
\usepackage[scale=0.85]{FiraMono}
\usepackage{FiraSans}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{\jobname}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{\jobname.dtx}
% \DoNotIndex{\newcommand, \newenvironment, \color, \colorlet,
%             \endinput, \upshape, \textbf, \textsf, \texttt, \mathbf, \mu,
%             \left, \right, \to, \ifthenelse, \isempty,
%             \mathbin, \mspace, \oplus, \mathsf}
% \iffalse
% https://tex.stackexchange.com/a/124809
% \fi
% \expandafter\DoNotIndex\expandafter{\string\{}
% \expandafter\DoNotIndex\expandafter{\string\}}
% \expandafter\DoNotIndex\expandafter{\string\&}
%
% \newcommand{\rolep}{\RoleFmt{p}}
% \newcommand{\roleq}{\RoleFmt{q}}
% \newcommand{\roleA}{\RoleFmt{A}}
% \newcommand{\roleB}{\RoleFmt{B}}
% \newcommand{\lblL}[1][]{\LabelFmt{l_{#1}}}
% \newcommand{\gtG}[1][]{\GlobalFmt{G_{#1}}}
% \newcommand{\gtGi}[1][]{\GlobalFmt{{G}'_{#1}}}
% \newcommand{\ltL}[1][]{\LocalFmt{L_{#1}}}
% \newcommand{\ltLi}[1][]{\LocalFmt{{L}'_{#1}}}
% \newcommand{\payloadT}[1][]{\PayloadFmt{T$_{#1}$}}
%\title{\textsf{mpstmacros} --- Macros for multiparty session types}
%\author{Fangyi Zhou\thanks{E-mail: me@fangyi.io}}
%\date{Version \fileversion~\filedate}
%
%\maketitle
% \begin{abstract}
%
% This package contains macros to typeset multiparty session types with
% standard constructs.
% Different syntactic categories are coloured differently, giving a better
% visual presentation and prevent potential confusions.
%
% \end{abstract}
%
% \section*{Forewords}
% This package is a collection of macros for typesetting multiparty session
% types (MPST).
% The author is not the sole creator of the macros, I would like to thank
% David Castro, Francisco Ferreira and Alceste Scalas for various version
% of MPST macros.
% I have taken inspiration from aforementioned versions and put them into
% this collection with examples.
% I hope it could be of use for future researchers who work in this area.
%
% With that said, the macros are by no means definitive.
% Feel free to grab them and modify them for your own extensions of MPST.
% Contributions are welcome, and can be made via pull requests on GitHub
% \url{https://github.com/fangyi-zhou/mpstmacros}.
%
% The examples in this document sometimes use macro conventions such as
% |\gtG| for a global type $\gtG$, and |\gtG[i]| for an subscript form
% $\gtG[i]$.
% If you find this useful, you may wish to look at
% \url{https://github.com/fangyi-zhou/magicvariables-sty}.
%
% \changes{0.0.3}{2022/02/11}{Fix missing \texttt{amsmath} import.}
%
% \section{Colouring and Formatting}
% We first describe the macros for setting colours: by design, we wish to
% give distinct colours for different syntax categories: namely,
% participants (roles), message labels, payload types, local types and
% global types.
% Optionally, type variables can be assigned a different colour, but
% is usually emphasised with a boldface font.
%
% \newcommand{\withcolour}[2]{{\color{#1}{#2}}}%
% \begin{itemize}
% \item
% \DescribeMacro{\colourRole}
% |\colourRole| defines the colour for roles, by default it is set to
% \withcolour{\colourRole}{Teal}.
%
% \item
% \DescribeMacro{\colourLabel}
% |\colourLabel| defines the colour for labels, by default it is set to
% \withcolour{\colourLabel}{Indigo}.
%
% \item
% \DescribeMacro{\colourPayload}
% |\colourPayload| defines the colour for payload types, by default it is
% set to \withcolour{\colourPayload}{DarkOrchid}.
%
% \item
% \DescribeMacro{\colourLocal}
% |\colourLocal| defines the colour for local session types, by default it
% is set to \withcolour{\colourLocal}{NavyBlue}.
%
% \item
% \DescribeMacro{\colourGlobal}
% |\colourGlobal| defines the colour for payload types, by default it is
% set to \withcolour{\colourGlobal}{VioletRed}.
%
% \item
% \DescribeMacro{\colourProc}
% |\colourProc| defines the colour for processes, by default it is set to
% \withcolour{\colourProc}{Maroon}.
%
% \item
% \DescribeMacro{\colourProcVar}
% |\colourProcVar| defines the colour for process variables, by default it
% is set to \withcolour{\colourProcVar}{Red}. Note that this colour does
% not apply to type variables in a recursive type.
% \end{itemize}
%
% Then, we use these colours to define formatting macros: they take one
% argument, which is the content to be formatted. Usually there is no need
% to change them, but you can re-define them to fit to your own
% perferences.
%
% \begin{itemize}
% \item
% \DescribeMacro{\RoleFmt}
% |\RoleFmt| applies the role colour, and uses sans serif font
% by default, for example, $\RoleFmt{A}, \RoleFmt{B}, \RoleFmt{C},
% \RoleFmt{p}, \RoleFmt{q}, \RoleFmt{r}$.
%
% \item
% \DescribeMacro{\PayloadFmt}
% |\PayloadFmt| applies the payload type colour, and uses typewriter font
% by default, for example, $\PayloadFmt{S}, \PayloadFmt{T},
% \PayloadFmt{int}, \PayloadFmt{bool}$.
%
% \item
% \DescribeMacro{\LabelFmt}
% \DescribeMacro{\LocalFmt}
% \DescribeMacro{\GlobalFmt}
% \DescribeMacro{\ProcFmt}
% |\LabelFmt|, |\LocalFmt|, |\GlobalFmt|, and |\ProcFmt|
% simply apply the corresponding colours for the given syntax category.
% |\LabelFmt| additionally applies san serif font.
% For example, label $\LabelFmt{l}$, local type $\LocalFmt{L}$, global type
% $\GlobalFmt{G}$, and process $\ProcFmt{P}$.
% \changes{0.0.2}{2022/01/25}{Use sans serif font for labels}
%
% \item
% \DescribeMacro{\TRecVarFmt}
% |\TRecVarFmt| is used to format type-level recursion variables, for
% example in a recursive global type or a recursive local type. By default,
% a boldface math font is used, for example $\TRecVarFmt{t}$ (no colour is
% attached, you can put it in a |\LocalFmt| or |\GlobalFmt| to give
% corresponding colour, like $\LocalFmt{\TRecVarFmt{t}}$ or
% $\GlobalFmt{\TRecVarFmt{t'}}$).
%
% \item
% \DescribeMacro{\PRecVarFmt}
% |\PRecVarFmt| is used to format process-level recursion variables, for
% example in a recursive process. By default, the macros applies its
% colour, for example, $\PRecVarFmt{X}$.\footnotemark
% \footnotetext{The reason why there are two macros for recursion variables
% is that (1) On the type level, we usually use an equi-recursive view to
% identify recursive types and their unfoldings, but not on the process
% level; and (2) Type variables and process variables should nonetheless be
% in separate syntactic categories or namespaces.}
% \end{itemize}
% \section{Global Types}
% We show the syntax of global types below:
%   \[
%     \begin{array}{rcll}
%       \gtG & ::= & & \text{Global Types} \\
%            & \mid  & \gtComm[i \in I]{\rolep}{\roleq}{\lblL[i]}{\payloadT[i]}{\gtGi[i]}
%                    & \text{Message} \\
%            & \mid  & \gtRec{t}{\gtG}
%                    & \text{Recursion} \\
%            & \mid  & \gtRecVar{t}
%                    & \text{Type Variable} \\
%            & \mid  & \gtEnd
%                    & \text{End}
%     \end{array}
%   \]
%
% \DescribeMacro{\gtComm}
% Message construct is rendered using |\gtComm|, it takes 6 arguments
% (including an optional argument for the subscript, usually for the index set),
% the remaining arguments are for sending role, receiving role, message
% label, payload type, and continuation.
% For example,
% \begin{verbatim}
% \gtComm[i \in I]{\rolep}{\roleq}{\lblL[i]}{\payloadT[i]}{\gtGi[i]}
% \end{verbatim}
% \[\gtComm[i \in I]{\rolep}{\roleq}{\lblL[i]}{\payloadT[i]}{\gtGi[i]}\]
%
% \DescribeMacro{\gtCommSingle}
% The singular form is rendered using |\gtCommSingle|, which does not
% include curly braces.
% It takes 5 arguments, same as |\gtComm| less the optional argument.
% For example,
% \begin{verbatim}
% \gtCommSingle{\rolep}{\roleq}{\lblL}{\payloadT}{\gtGi}
% \end{verbatim}
% \[\gtCommSingle{\rolep}{\roleq}{\lblL}{\payloadT}{\gtGi}\]
%
% When giving empty arguments to some of the arguments, selected constructs
% are not rendered by default.
% This is done via the macro |\commChoice|, which takes 3 arguments, label,
% payload type, and continuation respectively.
% This formatting macro is shared between global and local types.
% When the payload argument is empty, the parentheses are not rendered.
% For example,
% \begin{verbatim}
% \gtCommSingle{\rolep}{\roleq}{\lblL}{}{\gtGi}
% \end{verbatim}
% \[\gtCommSingle{\rolep}{\roleq}{\lblL}{}{\gtGi}\]
% When the continuation argument is empty, the dot (indicating sequencing)
% is not rendered.
% For example,
% \begin{verbatim}
% \gtCommSingle{\rolep}{\roleq}{\lblL}{\payloadT}{}
% \end{verbatim}
% \[\gtCommSingle{\rolep}{\roleq}{\lblL}{\payloadT}{}\]
%
% \DescribeMacro{\gtCommRaw}
% |\gtCommRaw| can also be used to render message construct, giving more
% flexibility for users to layout the internal elements.
% It takes 4 arguments (including an optional argument for the subscript),
% the remaining arguments are the sending role, receiving role, and the
% content inside the curly braces.
% The curly braces are dynamically size using |\left| and |\right|.
% This is especially helpful when typesetting examples, for example:
% \[
%   \gtCommRaw{\roleA}{\roleB}{
%     \begin{array}{@{}l@{}}
%       \commChoice{\LabelFmt{hello}}{\PayloadFmt{string}}{\gtG[hello]} \\
%       \commChoice{\LabelFmt{bye}}{\PayloadFmt{unit}}{\gtG[bye]}
%     \end{array}
%   }
% \]
% is produced by the following code:
% \begin{verbatim}
% \[
%   \gtCommRaw{\roleA}{\roleB}{
%     \begin{array}{@{}l@{}}
%       \commChoice{\LabelFmt{hello}}{\PayloadFmt{string}}{\gtG[hello]} \\
%       \commChoice{\LabelFmt{bye}}{\PayloadFmt{unit}}{\gtG[bye]}
%     \end{array}
%   }
% \]
% \end{verbatim}
%
% \DescribeMacro{\gtRec}
% |\gtRec| renders recursive types. It takes 2 arguments, namely the type
% variable and the inner global type. For example,
% \begin{verbatim}
% \gtRec{t}{\gtG}
% \end{verbatim}
% \[\gtRec{t}{\gtG}\]
%
% \DescribeMacro{\gtRecVar}
% |\gtRecVar| renders type variables. It takes a single argument, namely
% the variable itself. For example,
% \begin{verbatim}
% \gtRecVar{t}
% \end{verbatim}
% \[\gtRecVar{t}\]
%
% \DescribeMacro{\gtEnd}
% Finally, |\gtEnd| renders the termination. The macro does not take any
% argument.
% \begin{verbatim}
% \gtEnd
% \end{verbatim}
% \[\gtEnd\]
%
% \section{Local Types}
% We show the syntax of local types below:
%   \[
%     \begin{array}{rcll}
%       \ltL & ::= & & \text{Local Types} \\
%            & \mid  & \ltExtC[i \in I]{\rolep}{\lblL[i]}{\payloadT[i]}{\ltLi[i]}
%                    & \text{Receiving} \\
%            & \mid  & \ltIntC[i \in I]{\rolep}{\lblL[i]}{\payloadT[i]}{\ltLi[i]}
%                    & \text{Sending} \\
%            & \mid  & \ltRec{t}{\ltL}
%                    & \text{Recursion} \\
%            & \mid  & \ltRecVar{t}
%                    & \text{Type Variable} \\
%            & \mid  & \ltEnd
%                    & \text{End}
%     \end{array}
%   \]
%
% The local type macros work similar to global type macros.
% For both internal and external choices, there is a main macro, and
% \texttt{Single} and \texttt{Raw} variants, similar to |\gtComm| and its
% variants.
%
% \DescribeMacro{\ltIntC}
% Internal choice is rendered using |\ltIntC|, it takes 5 arguments
% (including an optional argument for the subscript, usually for the index set),
% the remaining arguments are for receiving role, message
% label, payload type, and continuation.
% For example,
% \begin{verbatim}
% \ltIntC[i \in I]{\rolep}{\lblL[i]}{\payloadT[i]}{\ltLi[i]}
% \end{verbatim}
% \[\ltIntC[i \in I]{\rolep}{\lblL[i]}{\payloadT[i]}{\ltLi[i]}\]
%
% \DescribeMacro{\ltIntCSingle}
% The singular form is rendered using |\ltIntCSingle|, which does not
% include curly braces.
% It takes 4 arguments, same as |\ltIntC| less the optional argument.
% For example,
% \begin{verbatim}
% \ltIntCSingle{\rolep}{\lblL}{\payloadT}{\ltLi}
% \end{verbatim}
% \[\ltIntCSingle{\rolep}{\lblL}{\payloadT}{\ltLi}\]
%
% \DescribeMacro{\ltIntCRaw}
% |\ltIntC| takes 3 arguments (including an optional argument for the subscript),
% the remaining arguments are the receiving role, and the
% content inside the curly braces.
% For example:
% \[
%   \ltIntCRaw{\roleB}{
%     \begin{array}{@{}l@{}}
%       \commChoice{\LabelFmt{hello}}{\PayloadFmt{string}}{\ltL[hello]} \\
%       \commChoice{\LabelFmt{bye}}{\PayloadFmt{unit}}{\ltL[bye]}
%     \end{array}
%   }
% \]
% is produced by the following code:
% \begin{verbatim}
% \[
%   \ltIntCRaw{\roleB}{
%     \begin{array}{@{}l@{}}
%       \commChoice{\LabelFmt{hello}}{\PayloadFmt{string}}{\ltL[hello]} \\
%       \commChoice{\LabelFmt{bye}}{\PayloadFmt{unit}}{\ltL[bye]}
%     \end{array}
%   }
% \]
% \end{verbatim}
%
% \DescribeMacro{\ltExtC}
% External choice is rendered using |\ltExtC|, it takes 5 arguments
% (including an optional argument for the subscript, usually for the index set),
% the remaining arguments are for sending role, message
% label, payload type, and continuation.
% For example,
% \begin{verbatim}
% \ltExtC[i \in I]{\rolep}{\lblL[i]}{\payloadT[i]}{\ltLi[i]}
% \end{verbatim}
% \[\ltExtC[i \in I]{\rolep}{\lblL[i]}{\payloadT[i]}{\ltLi[i]}\]
%
% \DescribeMacro{\ltExtCSingle}
% The singular form is rendered using |\ltExtCSingle|, which does not
% include curly braces.
% It takes 4 arguments, same as |\ltExtC| less the optional argument.
% For example,
% \begin{verbatim}
% \ltExtCSingle{\rolep}{\lblL}{\payloadT}{\ltLi}
% \end{verbatim}
% \[\ltExtCSingle{\rolep}{\lblL}{\payloadT}{\ltLi}\]
%
% \DescribeMacro{\ltExtCRaw}
% |\ltExtC| takes 3 arguments (including an optional argument for the subscript),
% the remaining arguments are the sending role, and the
% content inside the curly braces.
% For example:
% \[
%   \ltExtCRaw{\roleA}{
%     \begin{array}{@{}l@{}}
%       \commChoice{\LabelFmt{hello}}{\PayloadFmt{string}}{\ltL[hello]} \\
%       \commChoice{\LabelFmt{bye}}{\PayloadFmt{unit}}{\ltL[bye]}
%     \end{array}
%   }
% \]
% is produced by the following code:
% \begin{verbatim}
% \[
%   \ltExtCRaw{\roleA}{
%     \begin{array}{@{}l@{}}
%       \commChoice{\LabelFmt{hello}}{\PayloadFmt{string}}{\ltL[hello]} \\
%       \commChoice{\LabelFmt{bye}}{\PayloadFmt{unit}}{\ltL[bye]}
%     \end{array}
%   }
% \]
% \end{verbatim}
%
% \DescribeMacro{\ltRec}
% |\ltRec| renders recursive types. It takes 2 arguments, namely the type
% variable and the inner global type. For example,
% \begin{verbatim}
% \ltRec{t}{\ltL}
% \end{verbatim}
% \[\ltRec{t}{\ltL}\]
%
% \DescribeMacro{\ltRecVar}
% |\ltRecVar| renders type variables. It takes a single argument, namely
% the variable itself. For example,
% \begin{verbatim}
% \ltRecVar{t}
% \end{verbatim}
% \[\ltRecVar{t}\]
%
% \DescribeMacro{\ltEnd}
% Finally, |\ltEnd| renders the termination. The macro does not take any
% argument.
% \begin{verbatim}
% \ltEnd
% \end{verbatim}
% \[\ltEnd\]
%
% \section{Processes}
% This is future work.
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
% \section{Implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% We first define the colours.
%    \begin{macrocode}
\newcommand{\colourRole}{Teal}%
\newcommand{\colourLabel}{Indigo}%
\newcommand{\colourPayload}{DarkOrchid}%
\newcommand{\colourLocal}{NavyBlue}%
\newcommand{\colourGlobal}{VioletRed}%
\newcommand{\colourProc}{Maroon}%
\newcommand{\colourProcVar}{Red}%
\newcommand{\colourNet}{black}%
%    \end{macrocode}
%
% Some auxiliary helper functions:
%    \begin{macrocode}
\newcommand*{\mpstmacros@withcolour}[2]{{\color{#1}{#2}}}%
\newcommand*{\mpstmacros@ifempty}[3]{%
  \ifthenelse{\isempty{#1}}{#2}{#3}%
}%
\newcommand{\mpstDot}{\mathbin{.}}
\newcommand{\commChoice}[3]{%
  {#1}\mpstmacros@ifempty{#2}{}{(#2)}\mpstmacros@ifempty{#3}{}{\mpstDot{#3}}%
}%
%    \end{macrocode}
%
% Then we define the formatting macros:
%    \begin{macrocode}
\newcommand{\RoleFmt}[1]{\mpstmacros@withcolour{\colourRole}{\textsf{\upshape #1}}}%
\newcommand{\PayloadFmt}[1]{\mpstmacros@withcolour{\colourPayload}{\texttt{#1}}}%
\newcommand{\LabelFmt}[1]{\mpstmacros@withcolour{\colourLabel}{\mathsf{#1}}}%
\newcommand{\LocalFmt}[1]{\mpstmacros@withcolour{\colourLocal}{#1}}%
\newcommand{\GlobalFmt}[1]{\mpstmacros@withcolour{\colourGlobal}{#1}}%
\newcommand{\ProcFmt}[1]{\mpstmacros@withcolour{\colourProc}{#1}}%
\newcommand{\TRecVarFmt}[1]{\mathbf{#1}}%
\newcommand{\PRecVarFmt}[1]{\mpstmacros@withcolour{\colourProcVar}{#1}}%
%    \end{macrocode}
%
% Here we define global type macros.
%    \begin{macrocode}
\newcommand{\gtCommRaw}[4][]{\GlobalFmt{%
\mpstmacros@ifempty{#1}{%
{{#2} \to {#3} \left\{ {#4} \right\} }%
}{%
{{#2} \to {#3} {\left\{ {#4} \right\}}_{\mpstmacros@withcolour{black}{#1}}}%
}}}%
\newcommand{\gtComm}[6][]{\gtCommRaw[#1]{#2}{#3}{%
\commChoice{#4}{#5}{#6}%
}}%
\newcommand{\gtCommSingle}[5]{\GlobalFmt{%
{{#1} \to {#2} : \commChoice{#3}{#4}{#5}}%
}}%
\newcommand{\gtRec}[2]{\GlobalFmt{%
\mu\TRecVarFmt{#1}.{#2}%
}}%
\newcommand{\gtRecVar}[1]{\GlobalFmt{%
\TRecVarFmt{#1}%
}}%
\newcommand{\gtEnd}{\GlobalFmt{\texttt{\upshape end}}}%
%    \end{macrocode}
%
% Here we define local type macros.
%    \begin{macrocode}
\newcommand{\ltCRaw}[4][]{\LocalFmt{%
\mpstmacros@ifempty{#1}{%
{#2} {#4} \left\{{#3}\right\}%
}{%
{#2} {#4} {\left\{{#3}\right\}}_{\mpstmacros@withcolour{black}{#1}}%
}}}%
\newcommand{\ltIntCSymbol}{\LocalFmt{\oplus\mspace{-1mu}}}%
\newcommand{\ltExtCSymbol}{\LocalFmt{\&}}%
\newcommand{\ltIntCRaw}[3][]{\ltCRaw[#1]{#2}{#3}{\ltIntCSymbol}}%
\newcommand{\ltExtCRaw}[3][]{\ltCRaw[#1]{#2}{#3}{\ltExtCSymbol}}%
\newcommand{\ltIntC}[5][]{\ltIntCRaw[#1]{#2}{\commChoice{#3}{#4}{#5}}}%
\newcommand{\ltExtC}[5][]{\ltExtCRaw[#1]{#2}{\commChoice{#3}{#4}{#5}}}%
\newcommand{\ltIntCSingle}[4]{{#1}\ltIntCSymbol\mspace{2mu}{\commChoice{#2}{#3}{#4}}}%
\newcommand{\ltExtCSingle}[4]{{#1}\ltExtCSymbol{\commChoice{#2}{#3}{#4}}}%
\newcommand{\ltRec}[2]{\LocalFmt{%
\mu\TRecVarFmt{#1}.{#2}%
}}%
\newcommand{\ltRecVar}[1]{\LocalFmt{%
\TRecVarFmt{#1}%
}}%
\newcommand{\ltEnd}{\LocalFmt{\texttt{\upshape end}}}%
%    \end{macrocode}
%    \begin{macrocode}
\endinput
%</package>
%    \end{macrocode}
%\Finale
